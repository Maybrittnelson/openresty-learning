#
# 1. 与set_by_lua_block的区别：可以发起子请求，因为在set_by_lua中没有创建协程，任何调用yield的函数都被禁止。包括ngx.location.capture
# 2. Note that when calling ngx.exit(ngx.OK) within a rewrite_by_lua handler, the nginx request processing control flow will still continue to the content handler.
#    这也是ngx.OK和ngx.HTTP_OK的区别
# 3. rewrite指令可以发起内部请求。但是有两种情况：
#    last, rewrite指令执行完毕后立即跳转，所以rewrite_by_lua没有机会被执行
#    break，等到rewrite阶段的指令执行完毕后调准，rewrite_by_lua就有机会执行
#    rewrite_by_lua可阻止rewrite指令发起的跳转
# 4. rewrite_by_lua_no_postpone off时，rewrite_by_lua的指令将会被顺序执行
# 5. Nginx variables can be used in the <path-to-lua-script-file> string to provide flexibility
#    看来只要创建coroutine的指令，*_by_lua_file就支持变量插值
events {}

http {

    rewrite_by_lua_no_postpone on;

    server {
        location / {
            rewrite_by_lua_block {
                res = ngx.location.capture("/test")
            }
            proxy_pass http://localhost:9000;
        }

        location /test {
            echo "test nihao";
        }
    }

    server {
        listen 9000;
        location / {
            echo "9000 nihao";
        }
    }

    # 如果没有下面的指令，那么/bar location就会执行
    # 添加了rewrite_by_lua_no_postpone指令以后，就会顺序执行，所以会返回503错误
    server {
        listen 8001
        location / {
            # break 与 last 之间的区别
            rewrite_by_lua_block {
                ngx.exit(503)
            }
            rewrite ^ /bar last;
        }

        location /bar {
            echo "bar";
        }
    }
}
