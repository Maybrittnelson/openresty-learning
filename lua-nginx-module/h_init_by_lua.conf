events{}

#
# 时机：master加载nginx.conf
# 如果lua_code_cache off时，每个请求到来时，init_by_lua都将会被执行。因为每个请求都处在一个独立的LUA VM当中
# 在此处定义全局的共享变量，虽然不建议使用, 而且还有性能影响。正确的使用方式是将它们放在一个module里面，require进来
# lua code 免编译与lua code在系统中的份数是不想关的。即如果在init_by_lua阶段require了必须的模块后，根据copy-on-write，
# 所有的worker进程在内存上将共享一份code. 节省空间
#
# NOTICE: Only a small set of the Nginx API for Lua is supported in this context
# nginx的API可用的不多，有 ngx.log，ngx.shared.DICT. 看来主要就是加载模块、创建进程间共享空间
# 在此执行期间，LUA代码的权限是root
# 可以在该期间执行阻塞式操作
#

http {
    lua_package_path "${prefix}?.lua";
    lua_shared_dict dogs 1m;
    # 如果require函数被放在非init_by_lua的位置
    # NOTICE: 相当于在一个协程内部执行require操作, 相当于在某函数内部执行require操作。
    # 当下一个请求到来时，由于模块已经被加载，所以模块代码不会再次被执行（code cache）。
    # 但由于请求隔离机制的存在，在新的请求中是无法看到老的请求的全局变量a的，所以相当于使用了未定义的变量，所以为nil
    # NOTICE：在init_by_lua中执行时，代码是在全局环境下执行，所有的协程都能够共享在这里定义的全局变量
    init_by_lua_block {
        tt = require "libs/init_by_lua"
        dogs = ngx.shared.dogs;     -- reload 期间dogs内存不会被清除，数据都在
        --[[
            -- 相当于一个flag，表明reload时是否期望后面的代码被执行。
            -- 因为reload时VM重启，init_by_lua_block会重新被执行，通过dogs可以组织它初始化
        --]]
        if dogs:get("Tom") ~= nil then
            return
        end
        dogs:set("Jack", 100)
    }

    server {
        location / {
            content_by_lua_block {
                -- 注意require "libs/init_by_lua"在这里定义会有什么区别
                a = a + 1
                ngx.say(a)  -- a的值之所以一直为1，是因为请求隔离机制的存在。
            }
        }
    }

    server {
        listen 8001;
        location / {
            content_by_lua_block {
                ngx.say(dogs:get("Jack"))
                dogs:set("Jack", "nihao")
                dogs:set("Tom", true)
            }
        }
    }
}
