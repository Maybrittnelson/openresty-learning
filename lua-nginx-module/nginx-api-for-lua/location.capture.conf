#
# 1. 只能在同一个server内发起子请求；子请求内部可以做磁盘IO和网络IO操作，注意只要这些操纵是同步非阻塞的，就可以保证高性能；
# 2. 子请求并没有发起真正的HTTP请求，内部实现也许就是一个函数调用，所以高效。
# 3. You should always read the request body (by either calling ngx.req.read_body or configuring lua_need_request_body on) before initiating a subrequest.
# 4. ngx.location.capture 会将子请求的数据进行全部缓存，所以如果希望流式的传输数据，请用cosocket。
#
events{}

http {
    # NOTICE: NOTICE: NOTICE
    # You should always read the request body (by either calling ngx.req.read_body or configuring lua_need_request_body on) before initiating a subrequest.
    lua_need_request_body on;
    client_body_buffer_size 1m;
    client_max_body_size    1m;

    server {
        location /test {
            content_by_lua_block {
                ngx.say("test file")
            }
        }

        location / {
            content_by_lua_block {
                --[[
                    Note that subrequests issued by ngx.location.capture inherit all the request headers of the current request by default
                    如果这不是你所期望的，则需要在subrequest所在的location当中，执行：
                    proxy_pass_request_headers off 指令
                --]]
                local res = ngx.location.capture("/test")   -- 这个字符串还可以加parameters
                ngx.say(res.status)
                -- ngx.say只支持输出array类型的table
                ngx.say(res.header["Content-Length"])  -- header 本身是一个table，如果某个key有多个值，那么value将会是一个array table
                ngx.say(res.body)   -- It always buffers the whole response body of the subrequest in memory.
                ngx.say(res.truncated)  -- 子请求的响应体被阶段主要是有可能存在网络IO异常的情况，例如子请求去backend server读取数据时失败
            }
        }

        location /other {
            set $dog "$dog world";
            echo "$uri dog: $dog";
        }

        location /lua {
            set $dog 'hello';
            content_by_lua_block {
                --[[
                    1. method: e.g. ngx.HTTP_POST, 默认值ngx.HTTP_GET;
                    2. body: request body;
                    3. args: 支持string和table两种形式；
                    4. ctx: 如果向在父子请求之间共享一些数据的话。一般设置为ngx.var;
                    5. vars: 设置子请求中Nginx变量的值;
                    6. copy_all_vars: 相当于继承，Nginx variable values；
                    7. share_all_vars: 共享Nginx variable values，强烈不建议
                    8. always_forward_body: 为true时总是路由request body到子请求当中，主要是总是，前提是body未指定；默认情况下，只会在PUT和POST方法时，才会继承body
                    NOTICE：NOTICE：NOTICE：The request body read by either ngx.req.read_body() or
                    lua_need_request_body on will be directly forwarded to the subrequest without copying the whole request body data when creating the subrequest
                    即request body并没有copy一份出来，而是共用
                --]]
                res = ngx.location.capture("/other", {});
                ngx.print(res.body)
                ngx.say(ngx.var.uri, ": ", ngx.var.dog)
            }
        }
    }
}
