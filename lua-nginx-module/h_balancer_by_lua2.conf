#
# NOTICE：配置上还有一点问题，在backend server在返回失败的情况下，没有进行重试.
#
#
events{}
http {
    error_log logs/error.log info;
    proxy_next_upstream http_500;

    init_by_lua_block {
        idx = 0     -- NOTICE：在多个请求之间，全局变量是不被共享的
    }

    upstream backend {
        # balancer会忽略这些server指定的值
        server 0.0.0.1;   # just an invalid address as a place holder

        balancer_by_lua_block {
            -- NOTICE:  openresty已经将lua-resty-core继承进来，可直接使用
            local balancer = require "ngx.balancer"
            local host = "127.0.0.1"
            local port = 8001
            if idx == 1 then
                port = 8002
            end
            ngx.log(ngx.INFO, "port: ", port)
            --[[
                1. 因为没有创建协程，在balancer_by_lua中不能与外界通信；
                   最好的实现手段应该是定时器定时从storage中获取host-port，
                   然后更新到共享内存。balancer共享内存中获取数据
                2. balancer模块是lua-resty-core库中
            --]]
            local ok, err = balancer.set_current_peer(host, port)
            if not ok then
                --[[
                    1. 如果设置的host or port 不正确，response status code是502；
                       即没有进入该分支
                --]]
                ngx.log(ngx.ERR, "failed to set the current peer: ", err)
                return ngx.exit(500)
            end
            idx = 1
        }

        keepalive 10;  # connection pool
    }

    server {
        listen 8000;
        location / {
            proxy_pass http://backend/fake;
        }
    }

    server {
        listen 8001;
        location / {
            return 500;
        }
    }

    server {
        listen 8002;
        location / {
            echo "this is the fake backend peer...";
        }
    }
}
