events{}

http {
    server {
        location / {
            # NOTICE: 无论是echo还是ngx.say，默认输出方式都是chunked-transfer-encoding
            # 我想这也就是为什么这些指令可以被重复调用的原因吧
            content_by_lua_block {
                ngx.print("hello--world")     -- 被称为一个chunk data，也是因为传输时用chunked-transfer-encoding的方式
                ngx.say("mm nn")
            }

            # 1. arg[1]表示 input data chunk，如果有多个chunk，body_filter_by_lua_block会被调用多次.
            # 你通过tcpdump就能看出，nginx输出了两个chunk
            # 2. body_filter_by_lua_block要想被使用，必须使用chunked-transfer-encoding的方式传输数据。如果有content-length头，
            # 需要在header_filter_by_lua中删除。
            # header_filter_by_lua 'ngx.header.content_length = nil';
            #
            body_filter_by_lua_block {
                --[[
                local chunk = ngx.arg[1]
                ngx.log(ngx.INFO, chunk)
                 -- 下面的逻辑是说：如果当前chunk不包含hello，那么就不要输出该chunk
                if string.match(chunk, "hello") then
                    ngx.arg[2] = true  -- new eof
                    return
                end
                ngx.arg[1] = nil    -- 忽略该chunk
                --]]
            }
        }
    }
}
