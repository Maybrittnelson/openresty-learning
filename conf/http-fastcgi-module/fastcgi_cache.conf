events{}

http {
  #
  # Cache data are stored in files
  # 发送到后端服务器的request(cache key) --MD5 --选取key的后几位--> filepath --> Data
  #
  # level=1:2
  #    例如：md5值是b7f54b2df7773722d382f4809d65029c，内容就存放在c/29/b7f54b2df7773722d382f4809d65029c
  # use_temp_path
  #    默认值为on，cache data会先写到fastcgi_temp_path指定的目录下，然后重命名到fastcgi_cache_path指定的路径下
  #    如果设置为off，则直接将数据写到fastcgi_cache_path目录下
  #
  # keys_zone:
  #     存放的是cache data的元数据；One megabyte zone can store about 8 thousand keys.
  #
  # inactive:
  #    指定一个interval，如果在此期间cache没有被访问过，那么就删除该cache data. 默认缓存十分钟
  #
  # max_size:
  #    指定缓存空间的大小，如果超过，采用LRU算法。 这是由cache manager负责
  #
  # loader_files, loader_threshold, loader_sleep
  #    cache loader负责在程序启动时，根据磁盘上的data，构建cache zone
  #    loader_files: 因为一个文件对应一个request uri，所以它指的是一次interation最多加载的缓存条目
  #    loader_threshold：每次interation所持续的时间
  #    loader_sleep：interation之间的间隔时间
  #
  # purger(default is off), purger_files, purger_threshold, purger_sleep
  #    purger on时 purger process permanently iterates through all cache 
  #    entries and deletes the entries that match the wildcard key.(注意permanently， all cache entries，match wildcard)
  #    purger_files一次扫描的文件；purger_threshold: 一次interation的最长时间；purger_sleep时间间隔
  # 如何match？可以参见fastcgi_cache_purge， 不顾貌似pruger是不太需要的，毕竟已经有inactive字段了
  #
  fastcgi_cache_path /tmp/php_cache levels=1:2 keys_zone=cache_php:30m inactive=2s max_size=10g;
  server {
    location / {
      root /tmp/php;
      fastcgi_pass 127.0.0.1:9000;
      include fastcgi_params;
      fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
      
      # 上文和前面的配置都说明了它的必要性
      fastcgi_temp_path /tmp/fastcgi/temp;

      # 定义zone
      fastcgi_cache   cache_php;

      # 只要用户有一次访问，就cache
      fastcgi_cache_min_uses  1;

      # 指定cache key的值
      fastcgi_cache_key $request_uri;
      
      # 使得cache生效的必要项
      # 这个设置的时间和inactive设置的时间的区别？ 貌似都能生效，但是inactive指令生效的时间间隔不是太固定
      fastcgi_cache_valid   200 302  200s;
      
      # openresty指令直接不认识它 fastcgi_cache_purge     
      # fastcgi_cache_purge $request_uri;
    }
  }
}
