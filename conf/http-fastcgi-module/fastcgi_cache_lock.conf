events{}

http {
  fastcgi_cache_path /tmp/php_cache levels=1:2 keys_zone=cache_php:30m inactive=1d max_size=10g;
  server {
    location / {
      root /tmp/php;
      fastcgi_pass 127.0.0.1:9000;
      include fastcgi_params;
      fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
      
      fastcgi_temp_path /tmp/fastcgi/temp;
      fastcgi_cache   cache_php;
      fastcgi_cache_valid   200 302  1h;
      fastcgi_cache_key $uri;

      #
      # 默认值为off
      # 如何模拟它的作用，就通过php sleep的方式, 查看数据包.
      # off: 后端服务器接收到两个请求
      # on： 我们期许的是后面发送的请求不会发送给后端服务器，直接从cache中获取数据
      #   要使得上面的情况发生，还依赖fastcgi_cache_lock_age和fastcgi_cache_lock_timeout的值
      # fastcgi_cache_lock_age: 上一个请求在指定的时间内还没有返回，nginx会再发送一个请求到后端.
      # 避免发生某个后端服务器因为忙碌而没有时间响应，导致客户端受影响.
      # fastcgi_cache_lock_timeout: 超时时，nginx会发送请求到后端，但是该请求的响应不会被cache
      # 
      #
      fastcgi_cache_lock on;
      fastcgi_cache_lock_age  20s;
      fastcgi_cache_lock_timeout 20s;

      # 
      # “GET” and “HEAD” methods are always added to the list
      #
      fastcgi_cache_methods GET PUT POST;
    }
  }
}
