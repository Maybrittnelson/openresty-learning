events{}

http {
  server {
    location / {
      #
      # nginx在编译的时候默认就包含了http_fastcgi_module模块
      # 此处做一个最简单的nginx+PHP
      #
      fastcgi_pass 127.0.0.1:9000;

      root /tmp/php;
      include http-fastcgi-module/fastcgi_params;
      #
      # $fastcgi_script_name的值与$uri的值基本上一样
      # 如果只是指定$fastcgi_script_name, 那么php就会去文件系统的根目录下寻找/info.php文件
      #
      fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
      
      #
      # upstream sent too big header while reading response header from upstream
      # nginx拿这个buffer去存放response header，如果存放不下，就会报错。nginx 返回502 Bad Gateway
      #
      fastcgi_buffer_size 100;
      
      #
      # enabled:
      # nginx receives a response from the FastCGI server as soon as possible, 
      #  saving it into the buffers set by the fastcgi_buffer_size and fastcgi_buffers directives.
      #  If the whole response does not fit into memory, a part of it can be saved to a temporary file
      # 只是尽量读取后端服务器返回的内容，但是并不保证一次性读取完毕。
      #
      # disabled:
      # The maximum size of the data that nginx can receive from the server at a time 
      # is set by the fastcgi_buffer_size directive.
      #
      # 注意：后端服务器端可以通过X-Accel-Buffering，间接打开或关闭缓存选项，需要使用
      # fastcgi_ignore_headers X-Accel-Buffering
      #
      fastcgi_ignore_headers X-Accel-Buffering;
      fastcgi_buffering off;    # 只有打开该选项，后面的设置才会生效
      fastcgi_buffers 8 8k;
      fastcgi_temp_path  /tmp/fastcgi/temp;
      # Limits the size of data written to a temporary file at a time
      fastcgi_temp_file_write_size 8k;
      # sets the maximum size of the temporary file.
      fastcgi_max_temp_file_size 1024m;

      
      ########################################
      # 在fastcgi_buffers中一般选出两块内存用户响应客户端, 前提是所有的response还没有从后端服务器拿到
      # 那么如果已经读取了所有的response以后，我想应该是从temp读取8*8k的数据，因为异步，此时会把内存中的8*8k的数据
      # 先发送给客户端
      fastcgi_busy_buffers_size 16k;
    }
  }
}
