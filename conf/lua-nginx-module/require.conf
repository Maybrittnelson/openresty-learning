####
# 进入nginx的请求，并分是round－bind的形式进行分发的
# 当我们手工进行实验的时候，请求往往都发到了同一个worker中
####
events{}

http {

    init_by_lua_block {
        gnum = 10
        gl2 = {num=10}
    }

    init_worker_by_lua_block {
        gw = 100
        gwl2 = {num=100}
    }

    server {
        #
        # 通过require加载的模块是所有nginx-worker共享的, 那么这些worker当中由谁来进行更新，且能够保证数据的一致性呢？
        #
        location /by_lua_file {
            content_by_lua_file "conf/lua-nginx-module/foo.lua";
        }

        location /by_lua_block {
            content_by_lua_block {
                local bar = require "conf/lua-nginx-module/bar"
                bar.num = bar.num + 1
                ngx.say(bar.num)
            }
        }

        # 并没有做到数据累计的效果
        location /global {
            content_by_lua_block {
                gnum = gnum + 1
                gw = gw + 1
                ngx.say(gnum)
                ngx.say(gw)
            }
        }

        location /gl2 {
            content_by_lua_block {
                gl2.num = gl2.num + 1 
                gwl2.num = gwl2.num + 1 
                ngx.sleep(1)
                ngx.say(gl2.num)
                ngx.say(gwl2.num)
                ngx.say(ngx.worker.pid())
            }
        }
    }
}
