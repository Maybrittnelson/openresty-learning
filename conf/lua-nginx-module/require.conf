####
# 进入nginx的请求，并分是round－bind的形式进行分发的
# 当我们手工进行实验的时候，请求往往都发到了同一个worker中
####
events{
    accept_mutex off;   # 好像可以做到round-robind的效果, 至少每个worker多多少少能够接收到请求了
}

http {

    init_by_lua_block {
        gnum = 10
        gl2 = {num=10}
    }

    init_worker_by_lua_block {
        gw = 100
        gwl2 = {num=100}
    }

    server {
        #
        # 通过require加载的模块<bar>是worker内所有请求锁共享的模块
        # bar模块只会被加载一次
        #
        location /by_lua_file {
            content_by_lua_file "conf/lua-nginx-module/foo.lua";
        }
        
        # 与by_lua_file是同样的效果
        location /by_lua_block {
            content_by_lua_block {
                local bar = require "conf/lua-nginx-module/bar"
                bar.num = bar.num + 1
                ngx.say(bar.num)
                ngx.say(ngx.worker.pid())
            }
        }
 
        #
        # 并没有做到数据累计的效果，具体原因跟它们属于一个请求的不同执行阶段。
        # 正确的在不同的执行阶段共享变量的方法是利用ngx.ctx来完成
        #
        location /global {
            content_by_lua_block {
                gnum = gnum + 1
                gw = gw + 1
                ngx.say(gnum)
                ngx.say(gw)
                ngx.say(ngx.worker.pid())
            }
        }
        
        #
        # 类似ngx.ctx的效果
        #
        location /gl2 {
            content_by_lua_block {
                gl2.num = gl2.num + 1 
                gwl2.num = gwl2.num + 1 
                ngx.say(gl2.num)
                ngx.say(gwl2.num)
                ngx.say(ngx.worker.pid())
            }
        }
    }
}
