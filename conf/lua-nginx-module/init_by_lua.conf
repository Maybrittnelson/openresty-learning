events{}

#
# Do not initialize your own Lua global variables in this context
# because use of Lua global variables have performance penalties and can lead to global namespace pollution.
# The recommended way is to use proper Lua module files and call require() to load your own module
# files in init_by_lua or other contexts (require() does cache the loaded Lua modules in the global package.
# loaded table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).
# 一次
#

http {
    lua_code_cache on;
    #
    # do init work on the global Lua VM level
    # 如果lua_code_cache被设置为off，那么每个request都会启动一次VM，所以请求之间是相互独立的
    # 如果lua_code_cache被设置为on，那么每个init.lua文件也只会被执行一次, 在Master Context的环境中运行
    #
    # 所以，init_by_lua适合执行全局初始化
    # 可以调用blocking IO的操作
    # nginx的API可用的不多，有 ngx.log，ngx.shared.DICT
    #
    #init_by_lua_file lua/libs/init.lua;

    lua_package_path "${prefix}/lua/libs/?.lua";
    init_by_lua 'tt = require "init"';

    server {
        location / {
            content_by_lua_block {
                a = a + 1
                ngx.say(a)
            }
        }
    }
}
