events {}

http {
  #
  # 某些变量通过echo，输出的内容为空，这是对nginx理解不深的缘故，后面再深究原因
  # 发现另外一个好的查看这些变量值的方法, 就是在打印日志的时候
  # 貌似，openresty可以在每条日志打印的时候，指定它的格式，那样的话就更方便调试了
  #
  log_format old '$remote_addr $binary_remote_addr [$time_local] $status $request_time $body_bytes_sent $bytes_sent '
    '"$request" "$http_referer" "$http_user_agent" "$content_type" "$sent_http_date" "$request_body_file" "$realpath_root" ';
  access_log /tmp/access.log old;

  # 如果为on，curl返回的body大小与body_bytes_sent的大小就会有出入
  chunked_transfer_encoding off;

  server {
    server_name "localhost";
    location / {
      #
      # 用户发送的HTTP请求头
      # 在nginx端可以通过http_xxx访问到
      #
      #echo "user_agent: $http_user_agent";
      #echo "user_host : $http_host";
      #echo "accept    : $http_accept";

      #
      # 我在curl命令行参数中加入各种特殊字符，发现以下值得学习的内容：
      #
      # curl 'localhost?aaa=10&bbb=20'      这是标准的请求头参数，nginx会解析出来。
      #
      # GET /?bbb=10&aaa=dd#aaa HTTP/1.1
      # curl 'localhost?aaa=10#abc&bbb=20'  首先curl是把整个请求都发送过去了，nginx忽略了#后面的内容
      #
      # curl 'localhost?aaa=10@example.com' 如果出现@字符，那么将@前面认为是username:passwd
      #      如果没有冒号，那么前面就都认为是username; @后面是主机名称。最终的请求头Host的值就是@后面的内容
      #      具体内容，参见：http-auth-basic-module
      #
      # curl 'localhost?aaa=10&bbb=20[1-2]' []这是curl认为的特殊字符（因为我们已经用单引号引起来了), 它利用一个
      #      长连接发送多次请求，此处bbb=201， 然后发送bbb=202第二次。如果要发送[]字符，需要转义。
      #
      # crul 'localhost?bbb=10&||aaa=20' 请求头参数是非法形式，nginx解析不出来，因为&后面的||是不能作为变量名称的
      #       但是可以作为变量的值
      #
      #echo "arg_aaa   : $arg_aaa";
      #echo "arg_bbb   : $arg_bbb";
      #echo "arg_ccc   : $arg_ccc";
      #echo "args      : $args";

      #
      # remote_addr能够显示出来，因为输出的是IP地址的字符串形式
      # binary_remote_addr之所以显示不出来，不过可以在日志中输出该值
      # 它打印的是客户端的地址
      #
      #echo "binary_remote_addr: $binary_remote_addr";
      #echo "remote_addr: $remote_addr";

      # 
      # echo 永远输出0,日志中可以打印出response的body的大小
      # 如果响应头中存在Transfer-Encoding字段，你会发现返回的body size与log中记录的body size大小有
      # 出入，这都是Transfer-Encoding机制的影响
      # echo "hello"; 那么body的大小竟然是6（不是7），append了一个0a.
      # 4 132 通过这两个值比较我们发现，http header在只有Server、Date、Content-type、Connection四个时都占用了130个字节
      #
      #echo "body_bytes_sent:  $body_bytes_sent";
      # echo "bytes_sent:  $bytes_sent";

      #
      # nginx启动起来以后，每建立一个新的连接，这个connection的值就会加1
      # nginx -s reload 并不会清零
      #
      #echo "connection: $connection";

      #
      # 在http 1.1协议中连接默认是长连接
      # connection_requests记录了某一个连接发送的请求个数
      # 注意记录的不是总的请求数，而是一个连接的请求个数
      #
      #echo "connection_requests: $connection_requests";

      # 如果直接使用echo命令，此时response header中并不包括content-length字段
      # 所以$content_length什么也没有输出
      # 尝试的方法有在ngx中的content_by_lua和rewrite_by_lua中添加ngx.say和ngx.print方法，均失败
      # 尝试使用proxy_pass命令，这些echo就直接没有被执行起来
      # echo "content_length: $content_length";

      # 
      # 这个不但是在echo中为空，在log中也显示为空
      #
      #echo "content-type: $content_type";
       
      #
      # 与$uri的值相等
      # 即便是发生内部跳转，$uri和$document_uri的值得仍然是相等，是跳转后的uri
      #
      # echo "document_uri:  $document_uri";
      
      #
      # root or alias 命令指定的值相等
      # echo "document_root: $document_root";
      
      # 目前nginx要求所有的请求必须带有host字段, 所以它等于$http_host
      #echo "host: $host, $http_host";

      # 本机的主机名称
      #echo "hostname: $hostname";
     
      # 判断请求行当中是否存在请求参数,如果存在返回？
      #echo "is_args $is_args";
      
      #limit_rate 1000;
      #echo "limit_rate: $limit_rate";
      
      # nginx的版本 
      #echo "nginx_version: $nginx_version";

      # 以秒数的方式返回当前时间，小数点后三位是经过的毫秒数
      #echo "msec: $msec";

      # 打印进程的PID, 这样的一个好处是，我可以知道是哪一个worker处理
      # 比如测试负载均衡的时候，就是一个选择
      #echo "pid: $pid";
      
      # scheme 注意不包括冒号
      #echo "scheme: $scheme";
      
      #
      # 带了参数的URI, 或者成为完整的URI
      # 注意，发生内部跳转时该值是不随着改变的
      #
      #echo "request_uri: $request_uri";

      # 请求方法 
      #echo "request_method: $request_method";
      # 不是请求到来的时间，而是处理请求所花费的时间，精确到毫秒
      #echo "request_time: $request_time";
      # 与args的值是一样的，都不包括#后面的内容 
      #echo "query_string: $query_string";
      # including request line, header, and request body
      #echo "request_length: $request_length";

      # http/1.0 or http/1.1
      #echo "server_protocol: $server_protocol";
      # 200
      #echo "status: $status";
     
      #  nginx可以监听N个IP地址，告知这个请求是从那个端口上收上来的
      # 每次访问该变量都需要一次系统调用
      #  解决办法是name指定ip地址，且使用bind参数 
      #echo "server_addr: $server_addr";

      # 返回server_name中匹配到的值得
      # 并非本机的host名称
      #echo "server_name: $server_name";
      
      # 显示本地时间
      #echo "time_local: $time_local";
      
      # 还有一些参数是可以查看TCP连接设置的参数，连接的状况等
      # http://coolshell.cn/articles/11609.html  参见它们的解释
      #echo "tcpinfo_rtt: $tcpinfo_rtt";
      #echo "tcpinfo_rttvar: $tcpinfo_rttvar";
      #echo "tcpinfo_rcv_space: $tcpinfo_rcv_space"; #65483
      #echo "tcpinfo_snd_cwnd: $tcpinfo_snd_cwnd"; #10
 
      # 默认是非pipelined方式，但是如何打开呢？ 
      #echo "pipe: $pipe";

      # 原来request-id的值是由nginx唯一生成的,但是nginx直接启动失败，说是找不到request_id
      # echo "request_id: ${request_id}";
      
      #
      # sent_http_name 这个name是可以替代成响应的头部的,但是却没有成功
      # 看来响应的内容是无法在log里面体现出来的，因为content_type和sent_http_date都打印不出来
      #echo "sent_http_date: $sent_http_date";
      echo "hel";
    }

    location /body_bytes_sent {
    }
  }

  server {
    server_name myhost;
    location / {
      error_page 404 =200 /nihao;
    }
   
    location /nihao {
      # 此时输出的uri值是/nihao
      # 发送类似的请求：curl -i -H "Host: myhost" 'localhost/dsa'
      # request_uri:  /dsa
      # document_uri: /nihao
      # uri: /nihao
      echo "request_uri:  $request_uri";
      echo "document_uri: $document_uri";
      echo "uri: $uri";
    }
  }
  
}

