events {
}


http {
  # 根据文件的后缀名为content-type设置相应的值
  include mime.types;

  # 
  # the default value is off
  # 客户端应该包含Accept-Encoding:gzip头, content-type的值在gzip_type之内
  # server端对文件进行压缩，然后传输给客户端，curl命令此时得到一个压缩文件
  # 注意实际上是边压缩边传输，即server不会立刻知道压缩后文件的大小
  #
  # 那么Conetnt-Length的值如何确定？http 1.1 中引入了新的头Transfer-Encoding
  #
  gzip on;

  # 
  # Transfer-Encoding
  # 定义了一种新型的数据传输方法，适用于一开始不知大文件大小的情况下
  # https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81#.E6.A0.BC.E5.BC.8F
  # 默认值是on
  #
  # curl -I 返回的响应头中不包括Transfer-Encoding: chunked
  # 但实际传输这个文件的时候，server是返回了这个头部的
  # chunk大小虽然也是在body当中，通过tcpdump是可以捕捉得到的，但是curl >输出的内容只有文件相关的内容
  #
  chunked_transfer_encoding on;

  

  # the default value is text/html 
  # text/* is not wildcard
  gzip_types text/* text/html text/plain

  # the the default type
  default_type  application/octet-stream;

  server {
    listen 80;
    location / {
      proxy_pass http://localhost:8080;
    }
  }

  server {
    listen 8080;
    location / {
      root /tmp/;
#      echo "dd";
#      echo $request_uri;
    }
  }


}
