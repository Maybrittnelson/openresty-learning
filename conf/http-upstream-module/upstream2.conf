events {

}

http {
  #
  # 需要清楚什么是unsuccessful attempt, 对于不同的xxx_pass有不同的定义
  # Nginx 默认判断失败节点状态以connect refuse和time out状态为准
  # 定义了返回500是一个unsuccessful request
  #
  proxy_next_upstream http_500;

  upstream backend {
    
    server 127.0.0.1:8000;
    #
    # nginx将该请求转发至9000端口,该server返回了500错误。接下来会在backend中寻找其它server
    # 同时，nginx对server返回的unsucessful request请求+1，直到等于max_fails的值（默认值为1）。接下来的一段时间nginx
    # 将不会把请求转发给该server，这个时间段的长短由fail_timeout指定
    #
    server 127.0.0.1:9000 max_fails=3 fail_timeout=1000;
    
    #
    # 这是第三个server, 根据顺序9000端口的server如果返回500，接下来就会将该请求发送给10000端口
    # 如果server没有监听在该端口，那么直接返回502 Bad Gateway的错误。注意这种类型的错误，肯定会记录在fail attemp上的(并非是后端服务器返回的502)
    # 即便是server监听在该端口，返回的是500；nginx都会增加一次fail attempt；直到到达了max_fails
    # 在fail_timeout时间段内不进行任何转发请求给该server
    #
    server 127.0.0.1:10000 fail_timeout=10000;


    # 如果探测所有节点均失效，备机也为失效时，那么nginx会对所有节点恢复为有效，重新尝试探测有效节点，
    # 如果探测到有效节点则返回正确节点内容，如果还是全部错误，那么继续探测下去，当没有正确信息时，节点失效时默认返回状态为502
    # 但是下次访问节点时会继续探测正确节点，直到找到正确的为止。 
    #
    # 根据这两个功能，我们可以做一些日志报警类的工作
    # 确保应用程序不但活着，而且还能正常工作
    #
  }

  server {
    location / {
      proxy_pass http://backend;
    }
  }

  server {
    #listen 6000;
    #listen 7000;
    listen 9000;
    location / {
      return 500;
    }
  }

  server {
    listen 8000;
    location / {
      echo "8000";
    }
  }
}
