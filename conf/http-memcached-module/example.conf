events{}

http {
  server {
    location / {
      #
      # nginx每次请求都建立一个连接，这样做是不是太浪费时间了. 不过貌似proxy_pass之类的指令也是这么做的.(这是upstrema模块要做的事情，
      # 参见它的keepalive指令)
      # One should bear in mind that passing a request to the next server is only possible 
      # if nothing has been sent to a client yet. That is, if an error or timeout occurs in the 
      # middle of the transferring of a response, fixing this is impossible.
      # 一旦nginx将请求发送给了memcached服务器，memcached已经开始发送响应，cient已经接收了部分数据的情况下
      # nginx是不会将该请求再次转发到下一个memcache上的.
      #

      # 如何启动和设置一个key，很清楚
      # http://www.runoob.com/memcached/memcached-add-data.html
      #

      # 
      # 从memcached获取缓存数据，并返回给客户端
      # 如果不存在应该会返回404之类的错误
      #
      set $memcached_key "food";

      #
      # 如果指定的是域名的话，就有这个好处
      # If a domain name resolves to several addresses, all of them will be used in a round-robin fashion.
      # In addition, an address can be specified as a server group.
      # 也支持通过upstream模块，使用server group的方式，做负载均衡
      # 
      memcached_pass 127.0.0.1:11211;

      # The response is passed to the client synchronously, as soon as it is received.
      memcached_buffer_size 8k;

      error_page  404 502 504 = @fallback;
    }

    location @fallback {
      # 这里可以映射到真正的应用服务器，但是向memcached中添加data，仍然是应用服务器的事情
      # nginx并不会自动将返回的结果进行cache
      echo "not found" ;
    }
  }
}
