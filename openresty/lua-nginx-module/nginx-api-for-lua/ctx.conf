# NOTICE：ngx.ctx是在一个请求内部共享数据
# This table can be used to store per-request Lua context data and has a life time identical to the current request
# NOTICE: ngx.ctx本质上是一个table
#
events{}

http {
    server {
        location / {
            # ctx 提供了在一个请求的各个阶段进行数据共享的方法
            rewrite_by_lua 'ngx.ctx.foo=10';
            access_by_lua  'ngx.ctx.foo = ngx.ctx.foo + 10';
            content_by_lua 'ngx.say(ngx.ctx.foo)';
        }
    }

    # NOTICE NOTICE NOTICE: 每一个请求，包括子请求都拥有自己独立的ctx空间
    server {
        listen 8001;
        location /sub {
            content_by_lua_block {
                -- nil。表明：子请求不会继承父请求的ngx.ctx中的值
                -- NOTICE: NOTICE 子请求与父请求之间不要共享数据
                ngx.say("sub pre: ", ngx.ctx.blah)
                ngx.ctx.blah = 32
                ngx.say("sub post: ", ngx.ctx.blah)
            }
        }

        location /main {
            content_by_lua_block {
                ngx.ctx.blah = 73
                ngx.say("main pre: ", ngx.ctx.blah)
                local res = ngx.location.capture("/sub")
                ngx.print(res.body) -- 放置输出换行符
                ngx.say("main post: ", ngx.ctx.blah)
            }
        }
    }

    #NOTICE: 内部请求之间也无法通过ngx.ctx共享数据. 注意内部请求是有去无回的！
    #NOTICE: Internal redirection will destroy the original request ngx.ctx data (if any) and the new request will have an empty ngx.ctx table.
    server {
        listen 8002;
        location /new {
            content_by_lua_block {
           --     ngx.say(ngx.ctx.foo)
                ngx.ctx.foo = "world"
            }
        }
        location /orig {
            content_by_lua_block {
                ngx.ctx.foo = "hello"
                ngx.exec("/new")
            }
        }
    }
}


