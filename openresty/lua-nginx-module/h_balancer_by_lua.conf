#
# 1. can work with any existing nginx upstream modules like ngx_proxy and ngx_fastcgi.
#    它们被称为nginx upstream modules
# 2. 兼容ngx_http_upstream_module的keepalive指令，即balancer_by_lua支持与后端保持长链接
#    NOTICE: ensure that the keepalive directive is used after this balancer_by_lua_block
# 3. balancer_by_lua可以从server指令指定的静态backend中选择，
#    也可基于ngx.balancer module from the lua-resty-core library从动态server list中选择
#    NOTICE: 从中可以看到lua-resty-core库的重要性，关键是它是有LUA写的
# 4. 根据nginx upstream modules的标准，当某个后端无法处理该请求时，该请求会被重试，所以
#    balancer_by_lua的指令就可能会被执行多次(在一个请求过程中).
# 5. This Lua code execution context does not support yielding. 因为没有创建协程
events{}

http {
    error_log logs/error.log info;
    upstream foo {
        server 127.0.0.1:9001;
        server 127.0.0.1:9002;
        # 1. 处在upstream的上下文当中
        # 2. 无论选择哪一个upstream server，balancer_by_lua_block都会被执行
        # NOTICE: 那么balancer_by_lua如何去影响uostream的选择呢
        balancer_by_lua_block {
            ngx.log(ngx.INFO, "nihao")
        }
    }

    server {
        location / {
            proxy_pass http://foo;
        }
    }

    server {
        listen 9001;
        location / {
            echo "9001";
        }
    }

    server {
        listen 9002;
        location / {
            echo "9002";
        }
    }

}
